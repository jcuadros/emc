---
output:
  revealjs::revealjs_presentation:
    theme: simple
    slide_level: 2
    highlight: pygments
    center: false
    self_contained: true
    css: "../css/styles.css"
    reveal_options:
      slideNumber: true
      previewLinks: false
      transition: 0
      background_transition: 0
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dev="svg")
```
##

<img src="../images/IQSlogo.png" style="border-style:none;box-shadow:none;
position:absolute;margin:0;top:20px;left:20px;max-width:200px;height:auto;" />

<div style="font-size:1.5em;font-weight:700;margin-top:200px;">Control estadístico de procesos</div>
<div style="font-size:1.4em;font-weight:500;color:#333333;">Introducción a R</div>
<div style="font-size:1.2em;margin-top:40px;color:#333333;">Jordi Cuadros, Lucinio González</div>
<div style="margin-top:80px;color:#333333;">Diciembre de 2017</div>


# Elementos básicos de R

## R

R es un entorno y un lenguaje de programación estadística.

Es una de las herramientas más usadas en el análisis de datos. Es de código libre, su uso es gratuito y dispone de una comunidad muy activa que contribuye al desarrollo de herramientas y funciones adicionales (más de 10.000 paquetes) y a la resolución de preguntas a través de la red.

https://www.r-project.org/about.html
https://www.rdocumentation.org/
https://stackoverflow.com/questions/tagged/r 


## Instalación de R y RStudio

- **R**

    Se puede instalar desde https://cran.r-project.org/.


- **RStudio**
  
    Es una interfaz gráfica (o IDE) para la realización de cálculos y la programación en R.
  
    Se instala desde https://www.rstudio.com/, versión RStudio Desktop (Open Source License).

## R como herramienta de cálculo
**R** puede usarse desde la consola introduciendo directamente las instrucciones correspondientes.

```{r, echo = TRUE}
2 + 3 
8 ^ 10
log(100) # Logaritmo neperiano
``` 
\# indica que lo que sigue es un comentario

## Uso de *scripts*
Un *script* en R es un conjunto de instrucciones escritas en un archivo de texto, de forma que estás puedan almacenarse y ejecutarse con posterioridad. Se suelen almacenar con la extensión `.R`.

Un editor muy recomendado para la creación, ejecución y depuración de estos *scripts* es **RStudio**.

## Acceso a la ayuda
- Buscar ayuda sobre una función
```{r, echo = TRUE, eval = FALSE}
? "mean"
```
- Buscar un texto en la ayuda
```{r, echo = TRUE, eval = FALSE}
?? "anova"
```

En RStudio, se puede seleccionar y pulsar F1 para buscar en la ayuda

## Datos básicos
- *numeric*: número decimal de 15 dígitos significativos
- *integer*: entero de 32 bits (hasta 2·10^9^ aprox.)
- *logical*: `TRUE` o  `FALSE`
- *character*: cadena de caracteres de longitud indeterminada

## Datos básicos -- *numeric*
```{r, echo = TRUE}
a <- 2
a
class(a)
```

---- 

```{r, echo = TRUE}
b <- 13.6788956789
b
class(b)
print(b, digits = 10)
```

----

Operadores más comunes para datos de tipo *numeric*


-------------------      --------------------- 
Suma                              `+`  
Resta                             `-`
Producto                          `*`
División                          `/`
Potencia                       `^` o `**`
Módulo (residuo)                 `%%`
División entera                  `%/%`
Comparaciones              `== > < >= <= !=`
--------------           ---------------------

----

```{r, echo = TRUE}
a+b
a-b
a*b
```

----

```{r, echo = TRUE}
a^b
a/b

```

## Datos básicos -- *integer*
Permite almacenar números enteros. Es el tipo de datos usado para contadores e
índices.

```{r, echo = TRUE}
n <- as.integer(340000)
class(n)
n <- 2L
class(n)
```

## Datos básicos -- *character*
Permite almacenar cadenas de texto de longitud indeterminada.

Los literales se indican entre comillas dobles (o simples).

```{r, echo = TRUE}
a <- "aaa"
b <- "bbb"

paste(a, b, "hola", sep = ", ") 
```

----

Operadores más comunes para datos de tipo *character*


-------------------      --------------------- 
Comparaciones              `== > < >= <= !=`
-------------------      ---------------------

## Datos básicos -- *logical*
Almacena valores que son verdadero (`r T`) o falso (`r F`).

Es el resultado de una comparación.

```{r, echo = TRUE}
3 == 2
b <- 3 != 2 
b
```

----

Operadores más comunes para datos de tipo *logical*


-------------------      --------------------- 
Intersección lógica               `&`
Unión lógica                      `|`
Negación lógica                   `!`
Comparaciones                   `== !=`
-------------------      ---------------------

----

Por ejemplo...

```{r, echo = TRUE}
a <- TRUE
b <- F
a & b # Operador AND
a | b # Operador OR
!b  # Operador NOT
``` 

## Conversión a datos básicos
Las funciones de conversión de tipos en R se indican como `as.` seguido del tipo de dato de destino.

```{r, echo = TRUE}
as.character(2)
as.numeric(TRUE)
```

Para saber si una información o variable es de un tipo determinado puede usarse `is.` seguido del tipo de dato a comprobar.

## Constantes
R incorpora algunas constantes preestablecidas como
```{r, echo = TRUE}
pi
```

```{r, echo = TRUE, eval = FALSE}
Inf
NaN
NA
NULL
```

----

También existen funciones para evaluar si un dato corresponde a una de estas constantes.

```{r, echo = TRUE}
is.na(3)
is.null(NULL)
is.infinite(-Inf)
```

## Datos compuestos
- **Principales**
    - Vector
    - Factor
    - *Data frame* (Tabla de datos)
- Otros tipos comunes
    - Factor ordenado
    - Lista
    - Matriz

## Datos compuestos -- vector
```{r, echo = TRUE}
a <- c(2, 3, 4)
str(a)
a[2]
```

----

Las operaciones se aplican a vectores y devuelven vectores
```{r, echo = TRUE}
a + a 
a > 2.5
```

----

Atención al reciclaje de datos...
```{r, echo = TRUE}
a <- c(2, 3, 4)
b <- c(10, 20)
a * b
```

----

Las funciones en R suelen ser vectoriales

- algunas devuelven vectores
```{r, echo = TRUE}
a <- c(2, 3, 4)
abs(sin(a))
exp(a)
```

----

- otras devuelven valores agregados
```{r, echo = TRUE}
length(a)
sum(a)
mean(a)
```

También `sd`, `max`, `min`...

----

Puede determinarse si un valor está presente en un vector con el operador `%in%`.
```{r, echo = TRUE}
a <- c(2, 3, 4)
3 %in% a
c(2,5,3,4) %in% a
```

----

Existen estructuras especificas para crear vectores secuencia.
```{r, echo = TRUE}
1:10
seq(1, 10, by = 2)
seq(1, 3, length.out = 5) 
```

----

Los vectores se ordenan usando las funciones `sort` y `order`.
```{r, echo = TRUE}
a <- c(8, 2, 5, 3)
sort(a)
a[order(a)]
a[order(a,decreasing = T)]
```

##  Datos compuestos -- factor
Un factor es un vector de cadenas indexado. Normalmente se crea a partir del vector de cadenas de texto.

```{r, echo = TRUE}
a <- c("hola", "adeu","hola", "adeu", "adeu", "bye")
b <- as.factor(a)
as.character(b)
as.numeric(b)
str(b)
```
----

La función `factor` permite la codificación o recodificación manual de un vector. 
```{r, echo = TRUE}
a <- factor(c(3, 1, 3, 1, 1, 2), labels = c("adeu", "bye", "hola"))
a
levels(a)
```

## Datos compuestos -- *data frame*

```{r, echo = TRUE}
dfA <- data.frame(int = 1:10,
                  let = sample(letters, 10, replace = TRUE), 
                  ran = rnorm(10))
dfA
```
----

```{r, echo = TRUE}
dim(dfA) # Dimensión
nrow(dfA) # Número de columnas
ncol(dfA) # Número de filas
```

----

```{r, echo = TRUE}
str(dfA)
head(dfA, 3) # Primeros datos, 6 por defecto
tail(dfA, 2) # Últimos valores
```

----

Para acceder a los datos almacenados en el *data frame* se usan índices. Las variables de *data frame* también pueden extraerse usando su nombre.

```{r, echo = TRUE}
dfA[2,3]
dfA[,1]
dfA$let
```

Veremos más formas de acceder y usar los datos de una tabla de datos más adelante.

## Más datos compuestos -- lista
```{r, echo = TRUE}
a <- list(2, "2", FALSE)
b <- list(3, "hola", c(2, 3, 4))
```

<div style="column-count:2;">
```{r, echo = TRUE}
a
b
```
</div>

----

<div style="column-count:2;">
```{r, echo = TRUE}
length(a)
a[[3]]
b[[3]][1]
```

&nbsp;
<p style="display:block;break-after:column;"></p>

```{r, echo = TRUE}
str(b)
```

</div>

## Más datos compuestos -- factor ordenado
```{r, echo = TRUE}
notes <- c("Aprovat", "Insuficient", "Notable", "Insuficient",
           "Notable", "Excel·lent", "Aprovat")
notes <- factor(notes,
        levels = c("Insuficient", "Aprovat",
                   "Notable", "Excel·lent"),
        ordered = TRUE)
str(notes)
levels(notes)
```

## Más datos compuestos -- matriz
```{r, echo = TRUE}
a <- matrix(c(2, 4, -3, 5), ncol = 2)
a
a[2,2]
```

----
```{r, echo = TRUE}
a * a # Producto posición por posición
a %*% a # Producto matricial
t(a) # Transposición
```

## Instalación y carga de paquetes en R
R tiene muchos paquetes para resolver problemas específicos. Para usar un paquete adicional este debe instalarse y cargarse en memoria.

```{r, echo = TRUE, eval = FALSE}
installed.packages()[,1] # Lista los paquetes instalados
(.packages()) # Lista los paquetes en memoria
```

Dos recursos importantes para buscar y identificar paquetes relevantes son
https://www.rdocumentation.org/
https://cran.rstudio.com/web/views/

----

Para instalar un paquete, por ejemplo "nycflights13"
```{r, echo = TRUE, eval = FALSE}
install.packages("nycflights13")
```
Para cargar un paquete en memoria, se usa
```{r, echo = TRUE, eval = FALSE}
library("nycflights13")
```

En RStudio la gestión de paquetes también puede hacerse desde la interfaz del programa

----

En un script y para garantizar la disponibilidad de un paquete

```{r, echo = TRUE, eval = FALSE}
if(!require("nycflights13")) {
  install.packages("nycflights13")
  library("nycflights13")
}
```

----

Para acceder a la documentación de un paquete
```{r, echo = TRUE, eval = FALSE}
help(package="nycflights13")
```

Algunos paquetes tienen información adicional a la que se puede acceder con las funciones `vignette()` y `demo()`.


# Gráficos en R

## ¿Para qué usamos los gráficos?
La principales funciones de los gráficos en el análisis de datos son

- explorar los datos y facilitar su comprensión,
- permitir el descubrimiento de patrones no evidentes, y
- comunicar efectivamente los resultados de los análisis.


## Gráficos en R
Veremos dos paradigmas distintos para la creación de gráficos en R.

- Gráficos creados con el paquete `base`.
- Gráficos creados en base a la gramática de gráficos (*GoG*), usando el paquete `ggplot2`

## Gráficos en `base` R
Los gráficos en `base` R se construyen a partir de datos en vectores y usando funciones específicas en función del gráfico a realizar.

Para ejemplificar algunas de estas funciones, usaremos el conjunto de datos `mtcars`, que forma de los paquetes básicos de R.

----

```{r, echo = TRUE}
str(mtcars)
```

----

```{r, echo = TRUE}
head(mtcars, 10)
```

----

Veremos como crear

- gráficos de dispersión,
- histogramas,
- diagramas de barras, y 
- diagramas de caja (*boxplot*)

## Gráficos en `base` R -- gráfico de dispersión
```{r, echo = TRUE, eval = FALSE}
plot(mtcars$disp,mtcars$hp)
```

----

```{r, echo = FALSE, eval = TRUE}
plot(mtcars$disp,mtcars$hp)
```

----

## Gráficos en `base` R -- histograma
```{r, echo = TRUE, eval = FALSE}
hist(mtcars$disp)
```

Añadiendo una curva de densidad...
```{r, echo = TRUE, eval = FALSE}
hist(mtcars$disp,breaks=20,freq=FALSE)
lines(density(mtcars$disp))
```

----

```{r, echo = FALSE, eval = TRUE}
hist(mtcars$disp)
```

----

```{r, echo = FALSE, eval = TRUE}
hist(mtcars$disp,breaks=20,freq=FALSE)
lines(density(mtcars$disp))
```

----

## Gráficos en `base` R -- diagrama de barras
```{r, echo = TRUE, eval = FALSE}
barplot(table(as.factor(mtcars$cyl)))
```

----

```{r, echo = FALSE, eval = TRUE}
barplot(table(as.factor(mtcars$cyl)))
```

## Gráficos en `base` R -- diagrama de caja
```{r, echo = TRUE, eval = FALSE}
boxplot(mtcars$disp)
points(mean(mtcars$disp))
```

----

```{r, echo = FALSE, eval = TRUE}
boxplot(mtcars$disp)
points(mean(mtcars$disp))
```

## Gramática de gráficos (*GoG*)
La **gramática de gráficos** es una aproximación teórica al estudio de los componentes de un gráfico. De acuerdo con este análisis, un gráfico se puede construir mediante la especificación de un conjunto de capas y componentes que definen los datos, la asociación de los mismos a aspectos del gráfico, la especificación de la relación entre los valores de las variables de los datos con las del gráfico, la estructura geométrica del gráfico...

<p class="bibref">Wilkinson, L. (2006). The grammar of graphics. Springer Science & Business Media.</p>

## `ggplot2`
`ggplot2` es un paquete de R que implementa de la gramática de gráficos.

<p class="bibref">Wickham, H. (2010). A layered grammar of graphics. *Journal of Computational and Graphical Statistics*, 19(1), 3-28.</p>

Referencias:

- http://ggplot2.tidyverse.org/reference/
- https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf
- http://www.ling.upenn.edu/~joseff/avml2012/
- http://r-statistics.co/Complete-Ggplot2-Tutorial-Part1-With-R-Code.html

----

`ggplot2` forma parte del paquete `tidyverse` (aunque también puede instalarse y cargarse autónomamente).
```{r, echo = TRUE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("tidyverse")) {
  install.packages("tidyverse")
  library("tidyverse")
}
```

## `ggplot2` -- capas y elementos del gráfico
En `ggplot2` cada elemento gráfico que representa un conjunto de datos constituye una capa. Una o más capas constituyen un gráfico.

Cada capa queda definida mediante la especificación de sus elementos. Los principales son 

- datos,
- mapeado estético, y
- geometrías

----

En `ggplot2`, los gráficos constituyen un objeto de R y se construyen de forma aditiva.

Por ejemplo,

```{r, echo = TRUE, eval = FALSE}
grafico <- ggplot(data = anscombe,
        mapping = aes(x = x1, y = y1))  # Datos y mapeado estético 
grafico <- grafico + geom_point()       # Geometría

grafico
```

----

```{r, echo = FALSE}
grafico <- ggplot(data = anscombe,
        mapping = aes(x = x1, y = y1))  # Datos y mapeado estético 
grafico <- grafico + geom_point()       # Geometría

grafico
```

## `ggplot2` -- datos
En `ggplot2`, el elemento `data` (datos) se introduce como primer argumento de la función `ggplot`. Debe corresponder a una tabla de datos o un tipo de datos convertible a tabla de datos.

```{r, echo = TRUE, eval = FALSE}
grafico <- ggplot(data = anscombe,
```

## `ggplot2` -- mapeado estético
El `mapping` (mapeado estético) corresponde al establecimiento de relaciones entre variables de los datos y variables del gráfico. Es el segundo argumento de la función `ggplot`y debe crearse con al función de apoyo `aes`. 

```{r, echo = TRUE, eval = FALSE}
        mapping = aes(x = x1, y = y1))
```

----

Para variables cuantitativas, los mapeados más comunes corresponden a

- posiciones: `x`, `y`...
- tamaño: `size`
- color: `color`, `fill`

----

Para variable cualitativas, los mapeados más frecuentes son

- posiciones: `x`, `y`...
- color: `color`, `fill`
- forma: `shape`


## `ggplot2` -- geometrías
Las geometrías (`geom_`) indican la forma que debe tener el gráfico, es decir, cómo se articulan las variables del gráfico. Se añaden al gráfico sumándose al objeto creado por `ggplot`.

```{r, echo = TRUE, eval = FALSE}
grafico <- grafico + geom_point()
```

----

Son geometrías de uso común

- `geom_point`
- `geom_line`, `geom_vline`, `geom_hline`
- `geom_bar`
- `geom_histogram`
- `geom_boxplot`

Un resumen de las geometrías y su relación con las variables del gráfico que reconoce cada una de ellas figura en  https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf.


## Gráficos en `ggplot2`
Veremos cómo crear en `ggplot2` los gráficos más habituales, añadiendo algunas consideraciones para aquellos casos donde los gráficos realizados con `base` tienen prestaciones insuficientes.

- gráficos de dispersión,
- histogramas,
- diagramas de barras, y 
- diagramas de caja (*boxplot*).

De forma general, los gráficos en `ggplot2` se construyen a partir de tablas de datos (*data frames*), de los cuales se seleccionan las variables a representar.

----

Usaremos 1000 datos del conjunto de datos `diamonds` para crear los distintos ejemplos.

```{r, echo = TRUE}
diaM <- diamonds[sample(1:nrow(diamonds),1000),]
str(diaM)
```

## Gráficos en `ggplot2` -- gráfico de dispersión
```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price)) + geom_point()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price)) + geom_point()
```

----

Añadiendo una tercera variable (`cut`) y modificando algunos aspectos de formato...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3)
```

-----

Añadiendo líneas de tendencia...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3) +
  geom_smooth(method="lm",se=FALSE)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3) +
  geom_smooth(method="lm",se=FALSE)
```

## Gráficos en `ggplot2` -- histograma
```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price)) + geom_histogram(binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price)) + geom_histogram(binwidth=1000)
```

----

Y en función del corte...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

En frecuencias relativas (por grupo)...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,y=..density..,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,y=..density..,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

Quizás funcione mejor un gráfico de densidades...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_density(alpha=.3)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_density(alpha=.3)
```

## Gráficos en `ggplot2` -- diagrama de barras

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity)) + geom_bar()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity)) + geom_bar()
```

----

En función de la claridad...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar()
```

----

Para comparar entre frecuencias absolutas, funcionan mejor las barras separadas.

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="dodge")
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="dodge")
```

----

Para comparar entre frecuencias relativas acumuladas, son mejores las barras apiladas en frecuencia relativa (para cada clase).

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="fill")
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="fill")
```

----

Los diagramas de barras también pueden crearse a partir de tablas de datos agrupados. En este caso, debe indicarse qué variable es la `y` e incluir `stat="identity"` en el `geom_bar`.

## Gráficos en `ggplot2` -- diagrama de caja

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=1, y=price)) + geom_boxplot()
```

*NOTA: Para el `geom_boxplot` se requieren dos variables. Si no hay variable independiente se puede incluir `x=1`.*

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=1, y=price)) + geom_boxplot()
```

----

Y en función del corte...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=cut, y=price)) + geom_boxplot()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=cut, y=price)) + geom_boxplot()
```

----

El gráfico se puede mejorar mostrando todos los puntos, con una posición aleatorizada.

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=cut, y=price)) + 
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(shape = 21, alpha=.5,height=0,width=.2)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=cut, y=price)) + 
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(shape = 21, alpha=.5,height=0,width=.2)
```

----

O incluyendo un *violin plot* y un punto para la media...

```{r, echo = TRUE, eval = FALSE}
medias <- diaM %>% group_by(cut) %>%
  summarise(price=mean(price))

ggplot(diaM, aes(x=cut, y=price)) + 
  geom_violin() +
  geom_boxplot(outlier.shape = NA, width = 0.1) +
  geom_point(data=medias,shape=3)
```

----

```{r, echo = FALSE, eval = TRUE}
medias <- diaM %>% group_by(cut) %>%
  summarise(price=mean(price))

ggplot(diaM, aes(x=cut, y=price)) + 
  geom_violin() +
  geom_boxplot(outlier.shape = NA, width = 0.1) +
  geom_point(data=medias,shape=3)
```

## `ggplot2` -- elementos adicionales

Además de los elementos ya presentados (datos, mapeado estético y geometrías), otros elementos de `ggplot2` permiten controlar aspectos adicionales del gráfico, por ejemplo

- `scale_...`: controlan los aspectos relativos a la presentación de las variables del gráfico,
- `coord_...`: establecen el sistema de coordenadas usado en la geometría,
- `labs`: establece los títulos del gráfico,
- `theme`, `theme_...`: controlan la part del gráfico que no corresponde a datos (*non-data ink*), y
- `facet_`: permite la creació de secuencia de gráficos en función de una o dos variables

----

Un ejemplo para terminar...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat, y = price, shape = cut, col = clarity)) +
  geom_point(alpha=.6) +
  scale_x_continuous(breaks=1:3) +
  scale_y_continuous(trans="log10") +
  scale_color_brewer(palette="Spectral")+
  facet_grid(cut ~ clarity) + 
  theme_bw() + 
  theme(legend.position = "none",text = element_text(size=10))

```

----


```{r, echo = FALSE}
ggplot(diaM, aes(x=carat, y = price, shape = cut, col = clarity)) +
  geom_point(alpha=.8) +
  scale_x_continuous(breaks=1:3) +
  scale_y_continuous(trans="log10") +
  scale_color_brewer(palette="Spectral")+
  facet_grid(cut ~ clarity) + 
  theme_bw() + 
  theme(legend.position = "none",text = element_text(size=10))

```

# Estadística básica con R

## Funciones de la estadística
La **estadística**, como parte de la matemática que se ocupa de la recolección, análisis e interpretación de datos, tiene dos funciones principales

1. la descripción de conjuntos de datos (**estadística descriptiva**), y
2. la extracción de conclusiones a partir de estos datos (**inferencia**) 

En este repaso de la estadística básica, usaremos (de nuevo) el conjunto de datos `mtcars`.

----

```{r, echo = TRUE}
str(mtcars)
```

----

```{r, echo = TRUE}
head(mtcars, 10)
```

## Descriptiva de una variable
A menudo, el primer interés que tendremos es el de describir un conjunto de datos correspondientes a una sola variable. Esta es la situación con la que empezaremos.

¿Cómo se describe un conjunto de datos univariante? 

Normalmente se consideran los siguientes aspectos

- frecuencias y cuantiles,
- tendencia central (también llamado localización o posición),
- dispersión, y
- análisis de puntos extremos


## Descriptiva de una variable -- frecuencias y cuantiles
**Tamaño de la muestra o número de datos**
```{r, echo = TRUE}
length(mtcars$disp)
n <- sum(!is.na(mtcars$disp))
n
```

----

**Frecuencias absolutas y relativas**

Para una variable cuantitativa (*numeric*)...
```{r, echo = TRUE}
frec_abs <- table(cut(mtcars$disp,
      breaks=c(0,100,200,300,400,500,Inf)))
frec_abs

frec_rel <- frec_abs / n
frec_rel
```

-----

**Cuantiles**
```{r, echo = TRUE}
quantile(mtcars$disp,.1)
quantile(mtcars$disp,1:4*.2)
```

## Descriptiva de una variable -- tendencia central
```{r, echo = TRUE}
mean(mtcars$disp)
median(mtcars$disp)
```

## Descriptiva de una variable -- dispersión
```{r, echo = TRUE}
var(mtcars$disp) # el denominador es n-1
sd(mtcars$disp)
range(mtcars$disp)
```

----

```{r, echo = TRUE}
diff(range(mtcars$disp))
IQR(mtcars$disp)
mad(mtcars$disp) # mean absolute deviation
```

## Descriptiva de una variable -- puntos extremos
```{r, echo = TRUE}
lmin <- quantile(mtcars$disp,.25) - 1.5*IQR(mtcars$disp) 
lmax <- quantile(mtcars$disp,.75) + 1.5*IQR(mtcars$disp) 
mtcars$disp[mtcars$disp > lmax | mtcars$disp < lmin]
```

```{r, echo = TRUE}
lmin <- quantile(mtcars$qsec,.25) - 1.5*IQR(mtcars$qsec) 
lmax <- quantile(mtcars$qsec,.75) + 1.5*IQR(mtcars$qsec) 
mtcars$qsec[mtcars$qsec > lmax | mtcars$qsec < lmin]
```

## Descriptiva de una variable -- gráficos 
Gráficamente, son útiles para describir un conjunto de datos

- para variables cuantitativas: el diagrama de caja y el histograma

```{r, echo = TRUE, eval = FALSE}
boxplot(mtcars$qsec)
hist(mtcars$qsec)
```

- para variables cualitativas: el diagrama de barras

```{r, echo = TRUE, eval = FALSE}
barplot(table(factor(mtcars$cyl)))
```

----

```{r, echo = FALSE}
boxplot(mtcars$qsec)
```

----

```{r, echo = FALSE}
hist(mtcars$qsec)
```

----

```{r, echo = FALSE}
barplot(table(factor(mtcars$cyl)))
```

## Descriptiva de dos variables
Para el estudio y descripción de la relación entre dos variables, las técnicas más habituales incluyen

- los coeficientes de correlación, y muy especialmente el producto-momento de Pearson,
- las tablas de contingencia, y
- los gráficos de dispersión


## Descriptiva de dos variables -- coeficiente de correlación
**Producto-momento de Pearson**
```{r, echo = TRUE}
cor(mtcars$disp,mtcars$qsec)
```

**Coeficiente de correlación de Spearman**
```{r, echo = TRUE}
cor(mtcars$disp,mtcars$qsec, method = "spearman")
```

## Descriptiva de dos variables -- tabla de contingencia
```{r, echo = TRUE}
table(factor(mtcars$am),factor(mtcars$cyl))
```

## Descriptiva de dos variables -- gráfico de dispersión
```{r, echo = TRUE, eval = FALSE}
plot(mtcars$disp,mtcars$qsec)
```

----

```{r, echo = FALSE}
plot(mtcars$disp,mtcars$qsec)
```


## Distribuciones de probabilidad

## Inferencia

## Inferencia -- distribución

## Inferencia -- localización

## Inferencia -- dispersión

## Ajuste de modelos

## Regresión lineal


# Importación y exportación de datos


# Manipulación avanzada de tablas de datos

